<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Compiler Design - Tag - Eira Hazel</title>
        <link>http://localhost:1313/tags/compiler-design/</link>
        <description>Compiler Design - Tag - Eira Hazel</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 12 Mar 2025 01:00:00 &#43;0800</lastBuildDate><atom:link href="http://localhost:1313/tags/compiler-design/" rel="self" type="application/rss+xml" /><item>
    <title>Understanding Dominator Trees</title>
    <link>http://localhost:1313/posts/dominator-tree/</link>
    <pubDate>Wed, 12 Mar 2025 01:00:00 &#43;0800</pubDate>
    <author>xxxx</author>
    <guid>http://localhost:1313/posts/dominator-tree/</guid>
    <description><![CDATA[<p>&ldquo;Brief Discussion on Dominator Trees
Dominator trees are an important concept in graph theory, with wide applications in compiler optimization, program analysis, and other fields. I want to help everyone understand this concept through some simple explanations.</p>
<p>First, what is dominance? In a directed graph, if all paths from the starting point to a node v must pass through node u, then we say node u dominates node v, denoted as u dom v. Intuitively, to reach v, one must first pass through u - u acts like a &ldquo;checkpoint&rdquo; guarding access to v.</p>]]></description>
</item>
</channel>
</rss>
